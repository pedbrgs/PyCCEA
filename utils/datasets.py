import logging
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler, StandardScaler
from sklearn.model_selection import KFold, LeaveOneOut, StratifiedKFold


class DataLoader():
    """Load dataset and preprocess it to train machine learning algorithms.

    Attributes
    ----------
    data : pd.DataFrame
        Raw dataset.
    X : pd.DataFrame
        Raw input data.
    y : pd.Series
        Raw output data.
    X_train : np.ndarray
        Train input data.
    X_test : np.ndarray
        Test input data.
    y_train : np.ndarray
        Train output data.
    y_test : np.ndarray
        Test output data.
    n_examples : int
        Total number of examples.
    n_features : int
        Number of features in the dataset.
    n_classes : int
        Number of classes.
    classes : np.ndarray
        Class identifiers.
    train_size : int
        Number of examples in the training set.
    test_size : int
        Number of examples in the test set.
    seed : int, default None
        It controls the randomness of the data split.
    preset : bool, default False
        In some works, the training and testing sets have already been defined. To use them, just
        set this boolean variable to True.
    test_ratio : float
        Proportion of the dataset to include in the test set. It should be between 0 and 1.
    splitter_type : str
        Model selection strategy. It can be "k_fold" or "leave_one_out".
    kfolds : int or None
        Number of folds in the k-fold cross validation or in the leave-one-out cross validation.
    stratified : bool, default False
        If True, the folds are made by preserving the percentage of examples for each class. It is
        only used in case 'splitter_type' parameter is set to 'k_fold'.
    normalize : bool, default False
        If True, normalizes training and test sets generated by the split method.
    """

    # Class parameters
    SPLITTER_TYPES = ["k_fold", "leave_one_out"]
    PRIMARY_CONF_KEYS = ["general", "splitter", "normalization"]
    NORMALIZATION_METHODS = {"min_max": MinMaxScaler, "standard": StandardScaler}
    DATASETS = {
        "11_tumor": "11_tumor.csv",
        "9_tumor": "9_tumor.csv",
        "brain_tumor_1": "brain_tumor_1.csv",
        "brain_tumor_2": "brain_tumor_2.csv",
        "cbd": "cbd.csv",
        "dermatology": "dermatology.csv",
        "divorce": "divorce.csv",
        "dlbcl": "dlbcl.csv",
        "gfe": "gfe.csv",
        "hapt": "hapt.csv",
        "har": "har.csv",
        "isolet5": "isolet5.csv",
        "leukemia_1": "leukemia_1.csv",
        "leukemia_2": "leukemia_2.csv",
        "leukemia_3": "leukemia_3.csv",
        "libras": "libras.csv",
        "lsvt": "lsvt.csv",
        "lungc": "lungc.csv",
        "madelon_valid": "madelon_valid.csv",
        "mfd": "mfd.csv",
        "orh": "orh.csv",
        "prostate_tumor_1": "prostate_tumor_1.csv",
        "qsar_toxicity": "qsar_oral_toxicity.csv",
        "scadi": "scadi.csv",
        "shd": "shd.csv",
        "uji_indoor": "uji_indoor_loc.csv",
        "wdbc": "wdbc.csv"
        }

    def __init__(self, dataset: str, conf: dict):
        """
        Parameters
        ----------
        dataset : str
            Name of the dataset that will be loaded and processed.
        conf : dict
            Configuration parameters of the dataloader.
        """
        self.dataset = dataset
        self.conf = conf
        # Check if the data configuration file passed as parameter is valid
        for primary_key in DataLoader.PRIMARY_CONF_KEYS:
            if primary_key not in self.conf:
                raise AssertionError(
                    f"The '{primary_key}' section should be specified in the data configuration "
                    "file."
                )
        # Initialize logger with info level
        if self.conf["general"].get("verbose", True):
            logging.basicConfig(encoding="utf-8", level=logging.INFO)
        # Parse parameters
        self._parse_parameters()

    def _parse_general_parameters(self) -> None:
        """Parse parameters from the general section of the data configuration file."""
        if "splitter_type" not in self.conf["general"]:
            raise AssertionError(
                "The 'splitter_type' parameter should be specified in the general section of the "
                "data configuration file."
            )
        self.splitter_type = self.conf["general"]["splitter_type"]
        if self.splitter_type not in DataLoader.SPLITTER_TYPES:
            raise NotImplementedError(
                f"The splitter type '{self.splitter_type}' is not implemented."
            )
        self.seed = self.conf["general"].get("seed")
        self.verbose = self.conf["general"].get("verbose", True)

    def _parse_splitter_parameters(self) -> None:
        """Parse parameters from the splitter section of the data configuration file."""
        if self.splitter_type == "k_fold":
            if "kfolds" not in self.conf["splitter"]:
                raise AssertionError(
                    "The parameter 'kfolds' should be specified in the splitter section of the "
                    "data configuration file when 'splitter_type' is set to 'k_fold'."
                )
            self.kfolds = self.conf["splitter"]["kfolds"]
            self.stratified = self.conf["splitter"].get("stratified", False)
        if self.splitter_type == "leave_one_out":
            logging.info(
                "Careful! It is not recommended to use Leave-One-Out when your problem has large "
                "datasets or costly machine learning models to fit."
            )
            if "kfolds" in self.conf["splitter"]:
                logging.info(
                    "You specified the number of folds using Leave-One-Out (LOO). However, LOO is"
                    " equivalent to K-Fold when K is equal to the number of examples. Therefore, "
                    "the value of 'kfolds' parameter will be ignored in this case."
                )
            if "stratified" in self.conf["splitter"]:
                logging.info(
                    "You specified the 'stratified' parameter using Leave-One-Out (LOO). However," 
                    " the validation folds made by the LOO have only one sample. Therefore, the "
                    "value of 'stratified' parameter will be ignored in this case."
                )
        self.preset = self.conf["splitter"].get("preset", False)
        if self.preset:
            if self.conf["splitter"].get("test_ratio") is not None:
                logging.info(
                    "After setting both the 'preset' and 'test_ratio' parameters, the predefined "
                    "subsets will take precedence, rendering the 'test_ratio' parameter unused."
                )
            self.test_ratio = None
        else:
            self.test_ratio = self.conf["splitter"].get("test_ratio")
            if self.test_ratio is None:
                raise ValueError(
                    "The 'test_ratio' parameter should be specified in the splitter section of "
                    "the data configuration file when the 'preset' parameter is set to False or "
                    "is not defined in the splitter section."
                )
            if (self.test_ratio) <= 0 or (self.test_ratio >= 1):
                raise ValueError(
                    "The 'test_ratio' parameter should be within the range of 0 and 1, excluding "
                    "extreme values (i.e., 0 < 'test_ratio' < 1)."
                )

    def _parse_normalization_parameters(self) -> None:
        """Parse parameters from the normalization section of the data configuration file."""
        self.normalize = self.conf["normalization"].get("normalize", False)
        self.normalization_method = self.conf["normalization"].get("method")
        if self.normalize:
            if "method" not in  self.conf["normalization"]:
                raise AssertionError(
                    "The 'method' parameter should be specified in the normalization section of "
                    "the data configuration file when 'normalize' parameter is set to True."
                )
            if self.normalization_method not in DataLoader.NORMALIZATION_METHODS.keys():
                raise NotImplementedError(
                    f"The normalization method '{self.normalization_method}' is not implemented."
                )
            self.normalizer = DataLoader.NORMALIZATION_METHODS[self.normalization_method]()
        else:
            if self.normalization_method is not None:
                raise ValueError(
                    "The 'normalize' parameter should be set to True in the normalization section"
                    " of the data configuration file when 'method' parameter is specified."
                )

    def _parse_parameters(self) -> None:
        """Parse parameters, validate their values, and assign them to attributes."""
        self._parse_general_parameters()
        self._parse_splitter_parameters()
        self._parse_normalization_parameters()

    def get_ready(self) -> None:
        """
        Prepare the data for a Cooperative Co-Evolutionary Algorithm to perform feature selection.
        """
        self._load()
        self._preprocess()
        self._split()
        if self.normalize:
            self._normalize_subsets()
        self._model_selection()

    def _check_header(self, file: str) -> bool:
        """Check if a CSV file has a header.

        Parameters
        ----------
        file : str
            Name of the CSV file.

        Returns
        -------
        has_header : bool
            True if file has a header.
        """
        data = pd.read_csv(file, header=None, nrows=1)
        has_header = data.dtypes.nunique() != 1
        return has_header

    def _load(self) -> None:
        """Load dataset according to dataset given as a parameter."""
        try:
            path = f"./datasets/{DataLoader.DATASETS[self.dataset]}"
        except:
            # Check if the chosen dataset is available
            raise AssertionError(
                f"The '{self.dataset}' dataset is not available. "
                f"The available datasets are {', '.join(DataLoader.DATASETS.keys())}."
            )
        # Load dataset
        logging.info(f"Dataset: {self.dataset}")
        if self._check_header(path):
            self.data = pd.read_csv(path, header=None)
        else:
            self.data = pd.read_csv(path)

    def _get_input(self) -> pd.DataFrame:
        """Get the input data X from the dataset.

        By default, the penultimate column of the dataset is the label and the last is the
        predefined division of train and test set.

        Returns
        -------
        X : pd.DataFrame (n_examples, n_features)
            Input data (features).
        """
        X = self.data.iloc[:,:-2].copy()
        return X

    def _get_output(self) -> pd.Series:
        """Get the output data y from the dataset.

        By default, the penultimate column of the dataset is the label and the last is the
        predefined division of train and test set.

        Returns
        -------
        y : pd.Series (n_examples, )
            Output data (labels).
        """
        y = self.data.iloc[:,-2].copy()
        return y

    def _preprocess(self, dropna: bool = True) -> None:
        """Preprocess the dataset to be used by machine learning models.

        Parameters
        ----------
        dropna : bool, default False
            Remove rows that contains NaN values.
        """
        # Setting a default representation for NaN values 
        self.data.replace(to_replace = "?", value=np.nan, inplace=True)
        # Remove rows with at least one NaN value
        if dropna:
            self.data.dropna(inplace=True)
            self.data.reset_index(drop=True, inplace=True)

        # Split into input and output data
        self.X = self._get_input()
        self.y = self._get_output()

        # Labels as integer values
        self.y = self.y.astype(int)
        # Set number of examples
        self.n_examples = self.X.shape[0]
        # Set number of features
        self.n_features = self.X.shape[1]
        # Set number of classes
        self.n_classes = self.y.nunique()
        # Get class identifiers
        self.classes = sorted(self.y.unique())
        # Compute imbalance ratio
        minority_class = self.y.value_counts().min()
        majority_class = self.y.value_counts().max()
        self.imbalance_ratio = round(majority_class/minority_class, 4)

    def _split(self) -> None:
        """Split dataset into training and test sets."""
        if self.preset:
            logging.info("Using predefined sets...")
            # Get predefined training set
            train_idx, = np.where(self.data.iloc[:, -1] == "train")
            self.X_train = self.X.iloc[train_idx].to_numpy()
            self.y_train = self.y.iloc[train_idx].to_numpy()
            # Get predefined test set
            test_idx, = np.where(self.data.iloc[:, -1] == "test")
            self.X_test = self.X.iloc[test_idx].to_numpy()
            self.y_test = self.y.iloc[test_idx].to_numpy()
        else:
            logging.info("Splitting data...")
            # Split data into training and test sets
            self.X_train, self.X_test, self.y_train, self.y_test = (
                train_test_split(
                    self.X.to_numpy(),
                    self.y.to_numpy(),
                    test_size=self.test_ratio,
                    random_state=self.seed
                )
            )

        # Set subset sizes
        self.train_size = self.X_train.shape[0]
        self.test_size = self.X_test.shape[0]
        logging.info(f"Training set with {self.train_size} observations.")
        logging.info(f"Test set with {self.test_size} observations.")

    def _normalize_subsets(self) -> None:
        """Transform features in each subset (training and test) by the normalizer."""
        logging.info("Normalizing subsets...")
        # Normalization across instances should be done after splitting the data between training
        # and test set to avoid leakage
        self.normalizer.fit(X=self.X_train)
        self.X_train = self.normalizer.transform(X=self.X_train)
        # When normalizing the test set, it should apply the normalization parameters previously
        # obtained from the training set as-is
        self.X_test = self.normalizer.transform(X=self.X_test)

    def _model_selection(self) -> None:
        """Prepare data according to the specified splitter type."""
        logging.info(f"Splitter type: {self.splitter_type}.")

        if self.splitter_type == "k_fold":
            if self.stratified:
                self.splitter = StratifiedKFold(
                    n_splits=self.kfolds,
                    shuffle=True,
                    random_state=self.seed
                )
            else:
                self.splitter = KFold(
                    n_splits=self.kfolds,
                    shuffle=True,
                    random_state=self.seed
                )
        elif self.splitter_type == "leave_one_out":
            self.splitter = LeaveOneOut()
            # The number of folds will be equal to the number of training examples
            self.kfolds = self.train_size

        # Store training and validation folds built from the splitter
        self.train_folds = list()
        self.val_folds = list()
        for train_idx, val_idx in self.splitter.split(self.X_train, self.y_train):
            self.train_folds.append(
                [self.X_train[train_idx].copy(), 
                self.y_train[train_idx].copy()]
            )
            self.val_folds.append(
                [self.X_train[val_idx].copy(),
                self.y_train[val_idx].copy()]
            )
